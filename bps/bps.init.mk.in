### bps.init.mk -- Initialisation pour les modules `make'.

# Author: Michaël Le Barbier Grünewald
# Date: Ven 10 fév 2006 10:40:49 GMT
# Lang: fr_FR.ISO8859-15

# $Id: bps.init.mk 150 2009-09-05 17:13:32Z michi $

# BSDMake Pallàs Scripts (http://home.gna.org/bsdmakepscripts/)
# This file is part of BSDMake Pallàs Scripts
#
# Copyright (C) Michaël Le Barbier Grünewald - 2006-2009
#
# This file must be used under the terms of the CeCILL-B.
# This source file is licensed as described in the file COPYING, which
# you should have received as part of this distribution. The terms
# are also available at
# http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt


### SYNOPSIS

# .include "bps.init.mk"


### DESCRIPTION

# Rend des services dans le domaine de l'initialisation.
#
# Définit des pseudo-commandes CP, MV INSTALL, INSTALL_DIR,
# SED_INPLACE, etc.;
#
# Définit une valeur pour APPLICATIONDIR sur la base de la valeur de
# APPLICATION, si cette dernière a une valeur.
#
# Définit des pseudo-commandes WARN, INFO, MESG, FAIL utilisées pour
# le diagnostique.
#
# Définit `all' comme cible implicite.
#
# Demande le traitement des fichiers "bps.own.mk" et "bps.clean.mk"
#  et "Makefile.inc".
#
# Demande le traitement du fichier MAKEINITRC si cette variable est
# définie et que l'utilisateur courant n'est pas l'utilisateur
# root. Ceci permet d'utiliser le même Makefile pour installer des
# programmes `localement', et `globalement' avec la commande `sudo'.
#
# Définit la liste _MAKE_USERTARGET des cibles ``interface utilisateur''
# (all, clean, etc.). Voici la liste des ces cibles et les actions
# qu'elles doivent entreprendre:
#
#    * obj: créer l'arborescence nécessaire sous `objdir', le cas échéant
#    * configure: traite le code source pour l'adapter à
#       l'environnement courant;
#    * depend: traite le code source pour déterminer automatiquement
#       les dépendances entre certaines modules;
#    * build: prépare le programme;
#    * doc: prépare la documentation;
#    * all: configure, depend, build, doc;
#    * install: installer le programme et la documentation;
#    * clean: nettoie les fichiers produits lors de la préparation du
#       programme et de la documentation (y compris le programme et la
#       documentation eux-mêmes);
#    * distclean: comme clean, et nettoie les fichiers produits par
#       les étapes configure et depend.
#
#  Dans certains cas, il faut interpréter très librement le terme
#  `programme' utilisé ci-dessus.

#
# Description des variables
#

# MAKEINITRC
#
#   Fichier d'initialisation pour l'utilisateur.
#
#   Lorsque la variable USER ne vaut pas 'root', lorsque la variable
#   'MAKEINITRC' est définie et a comme valeur le nom d'un fichier,
#   ce fichier est lu par make pendant l'évaluation de ce module, après
#   lecture éventuelle de 'Makefile.inc'.
#
#   Ce mécanisme permet notamment à l'utilisateur de définir des valeurs
#   convenables à DESTDIR, BINOWN, etc. pour installer les objets dans
#   son répertoire personnel. Le rôle spécial de la valeur root permet
#   d'installer les programmes `system-wide' par un simple sudo, sans
#   avoir besoin d'efacer la variable MAKEINITRC.

# CP RM INSTALL INSTALL_DIR AWK SED SED_INPLACE ECHO.
#
#   Pseudo commandes.

# APPLICATION APPLICATIONDIR
#
#   Nom de l'application préparée.
#
#   La variable APPLICATION peut être définie par le client. Lorsque
#   c'est le cas la Collection de Makefiles en tient compte dans
#   certains endroits, notamment pour donner des noms de répertoires
#   censés être appropriés. C'est en fait la variable APPLICATIONDIR qui
#   joue ce rôle, on s'en sert par exemple pour définir
#   SHAREDIR=/share${APPLICATIONDIR}, etc.
#
#   SeeAlso: bps.own.mk bps.files.mk


### IMPLÉMENTATION

.if !target(__<bps.init.mk>__)
__<bps.init.mk>__:

.if exists(bps.config.mk)
.include "bps.config.mk"
.endif

### PSEUDO COMMANDES (BOOTSTRAP)

ID?= @ID@
.if !defined(UID)
UID!= ${ID} -u
.endif

.if !defined(USER)
USER!= ${ID} -n -u
.endif

.if !defined(GROUP)
GROUP!= ${ID} -n -g
.endif

## LECTURE DES FICHIERS DE CONFIGURATION

.if exists(${.CURDIR}/Makefile.inc)
.include "${.CURDIR}/Makefile.inc"
.elif exists(../${.CURDIR}/Makefile.inc)
.include "../${.CURDIR}/Makefile.inc"
.elif exists(../../${.CURDIR}/Makefile.inc)
.include "../../${.CURDIR}/Makefile.inc"
.elif exists(../../../${.CURDIR}/Makefile.inc)
.include "../../../${.CURDIR}/Makefile.inc"
.elif exists(../../../../${.CURDIR}/Makefile.inc)
.include "../../../../${.CURDIR}/Makefile.inc"
.endif

.if !(${UID} == 0) && defined(MAKEINITRC) && !empty(MAKEINITRC)
.if exists(${MAKEINITRC})
.include "${MAKEINITRC}"
.endif
.endif

## PSEUDO COMMANDES

ENVTOOL?=		env			# Le nom ENV
                                                #  appartient à sh(1)
CP?=			cp
RM?=			rm
MV?=			mv
LN?=			ln
LN_S?=			@LN_S@
MKDIR?=			mkdir
MKDIR_P?=		@MKDIR_P@
TAR?=			tar
INSTALL?=		@INSTALL@
INSTALL_DIR?=		@INSTALL@ -d
AWK?=			@AWK@
GREP?=			@GREP@
SED?=			@SED@
SED_INPLACE?=		${SED} -i .bk
TOUCH?=			touch
ECHO?=			echo
INFO?=			@echo '===>'
WARN?=			@echo 'Warning:'
FAIL?=			@echo 'Failure:'
MESG?=			@echo
NOP?=			@: do nada
SU?=			su

### VARIABLES

CLEANFILES?=
CLEANDIRS?=
DISTCLEANFILES?=
DISTCLEANDIRS?=
REALCLEANFILES?=
REALCLEANDIRS?=

## CIBLE IMPLICTE (all)

.MAIN:			all


## APPLICATIONDIR

.if defined(APPLICATION) && !empty(APPLICATION)
APPLICATIONDIR?=	/${APPLICATION}
.endif

## _MAKE_USERTARGET

_MAKE_USERTARGET?=
_MAKE_ALLSUBTARGET?=

.include "bps.own.mk"
.include "bps.objdir.mk"
.include "bps.autoconf.mk"

_MAKE_USERTARGET+= configure depend build doc all install
_MAKE_USERTARGET+= clean distclean realclean
_MAKE_ALLSUBTARGET+= configure depend build doc


#
# Héritage de certaines variables
#

# Les valeurs des variables DESTDIR et PREFIX sont exportées dans
# l'environnement.

.if empty(.MAKEFLAGS:MPREFIX=*)&&defined(PREFIX)
.MAKEFLAGS: PREFIX='${PREFIX}'
.endif

.if empty(.MAKEFLAGS:MDESTDIR=*)&&defined(DESTDIR)
.MAKEFLAGS: DESTDIR='${DESTDIR}'
.endif

.endif # !target(__<bps.init.mk>__)

### End of file `bps.init.mk'

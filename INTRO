INTRO -- Introduction à la Collection de Makefiles

Author: Michaël Le Barbier Grünewald
Date: Ven 10 fév 2006 16:50:40 GMT
Lang: fr_FR.ISO8859-1

$Id$

Avertissement: ces notes concernent les personnes intéressées par la
 méthodologie de l'écriture des directives pour BSD Make.


Le programme `make' aide l'utilisateur à garder à jour les fichiers
objets associés à un ou plusieurs fichiers sources. Le programme
`make' doit être informé par l'utilisateur des relations entre les
objets et les sources.  La Collection de Makefiles fournit une partie
des déclarations décrivant les relations entre certains associations
objet/source couramment rencontrées sur une station de travail. La
peine de l'utilisateur de la Collection de Makefiles se trouve donc
amoindrie.

Le vocabulaire objet/source est décrit dans la section SOURCES ET
OBJETS.  La méthodologie dirigeant l'élaboration des modules de la
Collection de Makefiles est décrite dans la section MÉTHODOLOGIE.



MÉTHODOLOGIE

PARTAGE DES MODULES. Certains modules de la collection ne contiennent
pas des spécifications utiles en elle-mêmes mais fournissent des
services à d'autres modules, ainsi le fichier `make.files.mk' fournit
aux modules qui en sont clients une procédure pour installer les
fichiers, ce qui décharge les clients du travail d'écrire entièrement
une procédure d'installation originale. Les modules qui fournissent
des services à d'autres sont des _modules internes_, les autres, ceux
qui fournissent leurs services à l'utilisateur sont des _modules
d'interface_.

Chaque module d'interface propose un ensemble de services réduit et
ciblé: un module peut par exemple proposer tous les services
nécessaires à la préparation d'un document TeX (préparation de fichier
dvi, préparation de fichier PostScript, préparation de fichier PDF,
installation, ou plutôt publication), le traitment des images, etc,
mais ne devrait pas permettre en plus la compilation de programmes en
C, par exemple, qui n'a semble-t-il rien à voir avec TeX (à moins que
vous n'utilisiez les programmes CWEAVE/CTANGLE, il faudrait alors
utiliser des fichiers de directives spécifiques à ce cas).

SERVICES FOURNIS PAR LES MODULES. Les services fournis sont partagés
en deux groupes: les services de production qui produisent les objets
à partir des sources, et les services adminsitratifs, ou services
d'encadrement, qui délivrent l'utilisateur de certains problèmes
fortement liés aux objets produits. Comme exemple de problème
fortement liés, on cite la destruction des objets produits,
l'installation des objets, la création d'une archive renfermant les
objets produits, la publication des objets si'il s'agit de documents
éléctroniques, l'inscription des objets dans telle ou telle base de
donées, etc.

  Exemple: services liés à la production des objets
  Lorsqu'on utilise la Collection BSD des Makefiles, pour les sources
  de FreeBSD, les modules installent les objets, produits, publient
  les pages de manuel et les autres fichiers de documentation.  Dans
  le système des ports(7), les modules peuvent également inscrire la
  tierce application nouvellement installée dans la base de données
  des pacakges (cf. ports(7), pkg_add(1)).


SERVICES DE PRODUCTION. Les services de production doivent permettre
de préciser des paramètres de production particuliers pour chaque
paire OBJET/SOURCE.

  Exemple 1: paramètres particuliers pour la compilation.
  Le fichier tricky_hack.c doit être compilé par GCC avec des
  paramètres particuliers, -fomit-frame-pointer -fshcedule-insns. Le
  module rendant le service de compilation doit prévoir de comprendre
  une déclaration du genre

    CFLAGS.tricky_hack.c = ${CFLAGS} -fomit-frame-pointer -fshcedule-insns

  XXX Exemple 2: make.files.mk. etc.

  Remarque: dans l'Exemple 1., on a choisi d'étiquetter les paramètres
  spécifiques à producuction de la paire OBJET/SOURCE  par le nom du
  fichier source --- il n'y a ici qu'un seul fichier source. Un autre
  choix possible est de proposer à l'utilisateur d'écrire

    CFLAGS.tricky_hack.o = ${CFLAGS} -fomit-frame-pointer -fshcedule-insns

  en retenant cette fois comme étiquette le nom de l'objet
  produit. Lorsqu'il faut choisir entre les deux façons, les
  considérations suivantes sont à étudier:

    1. le mieux est d'utiliser comme étiquette un nom qui apparaît
       déjà dans le fichier de directives, par exemple bsd.prog.mk
       compile _un_ programme et demande à l'utilisateur de ranger la
       liste des sources dans SRCS. Dans cet exemple, tricky_hack.c
       apparaît à l'endroit de la déclaration de SRCS, et
       tricky_hack.o n'apparaît à aucun autre endroit. On préfère
       alors utiliser tricky_hack.c comme étiquette.

    2. Lorsqu'un objet a plusieurs fichiers sources, il vaut mieux
       utiliser le nom de l'objet, c'est le cas pour l'édition des
       liens par exemple.

Voici une stratégie simple permettant le choix de ces paramètres.
Pour commencer, on définit des paramètres globaux qui régissent la
production des objets en l'absence d'information supplémentaire.
Ensuite on parcourt la liste des OBJETS/SOURCES et on définit les
paramètres locaux à chaque production d'objet en concordance avec les
paramètres choisis par l'utilisateur en se rabattant sur le paramète
global correspondant lorsqu'un certain paramètre local n'est pas
défini.

	Exemple. Compilation d'objets du langage C.
	BIN =		some_binary
	SRCS =		module1.c module2.c main.c
	OBJS =		module1.o module2.o main.o # AUTO: OBJS=${SRCS:.c=.o}
	CFLAGS =	-W all

	.for item in ${SRCS}
	.for para in CFLAGS
	.if !defined(${para}.${item:T})
	${para}.${item:T}=${${para}}
	.endif
	.endfor
	.endfor

	.for item in ${SRCS}
	${item:.c=.o}: ${item}
		${CC} ${CFLAGS.${item:T}} -o ${.TARGET} ${.ALLSRC}
	.endfor

On recommande même d'associer à chaque paire OBJET/SOURCE une variable
qui contient la ligne de commande régissant la production de
l'objet. Cette variable peut appartenir au domaine privé, puisqu'il
paraît exceptionnel que l'utilisateur veuille modifier cette ligne.

	Exemple. Compilation d'objets du langage C.
	BIN =		some_binary
	SRCS =		module1.c module2.c main.c
	OBJS =		module1.o module2.o main.o # AUTO: OBJS=${SRCS:.c=.o}
	CFLAGS =	-W all

	.for item in ${SRCS}
	.for para in CFLAGS
	.if !defined(${para}.${item:T})
	${para}.${item:T}=${${para}}
	.endif
	.endfor
	.endfor

	.for item in ${SRCS}
	.if !defined(_BUILD.${item:T})
	_BUILD_${item:T}=${CC}
	# L'ajout d'une variable de contenu vide produit des espaces
	# indésirables sur la ligne de commande.
	if !empty(CFLAGS.${item:T})
	_BUILD.${item:T}+=${CFLAGS.${item:T}}
	.endif
	if !empty(CNAME_${item:T})
	_BUILD.${item:T}+=-o ${CNAME.${item:T}}
	.endif
	_BUILD.${item:T}+=${item}
	.endif#!defined(_BUILD.${item:T})

	.for item in ${SRCS}
	${item:.c=.o}: ${item}
		${_BUILD.${item:T}}
	.endfor

Le bloc avec les variables dont le nom admet _BUILD comme préfixe a
pour rôle de calculer les lignes de commande nécessaires à la
préparation de l'objet. Cette méthode offre les meilleurs possibilités
en termes de flexibilité. Bien sûr il faut veiller à ce que des
modules différents travaillant sur un même ensemble de sources et
d'objets n'interfèrent pas entre eux; et par conséquent éviter
d'utiliser le même préfixe pour toutes les variables internes dans
tous les modules (GAGA).



SOURCES ET OBJETS

Beaucoup de programmes opèrent de la façon suivante:
  - l'utilisateur fournit un ensemble de données, réparties dans
	un ou plusieurs fichiers;
  - le programme traite l'ensemble des données et inscrit ses
	résultats dans un fichier, qui peut ainsi être consulté plus
	tard ou faire lui-même l'objet de traitements ultérieurs.

Les programmes adoptant ce mode opératoire mettent en relation les
fichiers fournis par l'utilisateur et les fichiers de résultat du
traitement. Pour cette relation, on dit que les fichiers fournis par
l'utilisateur sont les SOURCES des fichiers de résultats, et que les
fichiers de résultats sont les OBJETS issus des fichiers fournis par
l'utilisateur.

  Exemple 1: Le programme TeX.

  Le programme TeX compose un document imprimable à partir d'une
  description qu'en donne l'utilisateur.

  Alice a écrit un texte pour ses étudiants, le texte est un peu long
  et pour faciliter son travail, elle l'a partagé en plusieurs
  fichiers, et ce partage correspond à la strucutre du texte. Le texte
  proprement dit est contenu dans les fichiers

    intro.tex sec1.tex sec2.tex concl.tex biblio.tex

  et elle a écrit deux fichiers supplémentaires, qui ne ne relèvent
  pas à proprement parler du contenu de son document mais aident TeX à
  traiter correctement ces fichiers. Une partie de son document
  nécessite une composition particulière, et elle a du écrire des
  macros supplémentaires, qu'elle a placées dans un fichier
  indépendant, spmac.tex. Elle a aussi écrit un petit fichier qui
  indique à TeX où trouver toutes ces nourritures, feedtex.tex.

  Pour préparer son document, Alice lance

    $ tex feedtex

  et obtient les fichiers suivants

    feedtex.dvi feedtex.log

  Dans le vocabulaire SOURCES/OBJETS, les fichiers

    intro.tex sec1.tex sec2.tex concl.tex biblio.tex
	spmac.tex feedtex.tex

  sont les sources de feedtex.dvi et feedtex.log, tandis que
  feedtex.dvi et feedtex.log sont les objets de intro.tex sec1.tex
  sec2.tex concl.tex biblio.tex, spmac.tex et feedtex.tex. On ne prête
  pas toujours le même intérêt à tous les fichiers résultant de
  l'éxécution d'un programme. Ici le fichier feedtex.log est un
  rapport d'éxécution et comme TeX n'a pas décelé d'erreurs, ce
  fichier n'intéresse pas du tout Alice.


  Exemple 2: le programme dvips

  Le programme dvips traduit le fichier DEVICE INDEPENDENT produit par
  TeX en un fichier Adobe PostScript, adéquat pour être imprimé sur
  une imprimante qui comprend le langage PostScript.

  Après avoir obtenu le fichier feedtex.dvi, Alice a besoin d'en
  produire une traduction spécifique pour le prériphérique de sa
  station de travail qui va finalement imprimer le document. Elle a à
  sa disposition une imprimante PostScript, et décide de
  l'utiliser. La commande

    $ dvips -o feedtex.ps feedtex.dvi

  produit le fichier feedtex.ps dont elle a besoin [1,2]. Ici le fichier
  feedtex.dvi est une source pour le fichier feedtex.ps et feedtex.ps
  est l'objet.

  [1] Bien-sûr elle aurait pu dire dvips feedtex.dvi, mais ça
      n'est plus un exemple de relation SOURCE/OBJET, et puis Alice a
      de toute façon besoin du fichier PostScript parceque
      l'administration de la faculté le lui demande.

  [2] La commande utilisée par Alice est en fait adaptée à la
      publication éléctronique de son fichier PostScript, pour créer
      un fichier destiné à l'impression il vaut mieux avoir configuré
      préalablement son imprimante (par exemple avec texconfig) et
      utiliser le nom de cette configuration avec l'option -P de dvips.


  XXX Exemple 3: le compilateur GNU cc

  Remarque: c'est dans la production de fichiers de code machine que
   l'on parle ordinairement de fichiers objets.
  Remarque: parfois la relation est la même pour toute une classe
   de programmes: des compilateurs différents peuvent produire des
   objets de contenu éventuellement différents, mais les fichiers
   sont néanmoins homonymes.



HOOK TARGETS


L'utilisateur de fichiers de directives Make génériques a parfois
besoin de raffiner les procédures créées automatiquement par ces
directives. Un raffinement ordinaire consiste à insérer des commandes
avant et après les commandes générées automatiquement pour la
production d'une certaine cible. Pour faciliter cette opération,
la Collection de Makefiles définit les cibles administratives

  all, build, doc, clean, distclean, install, depend, configure

de la façon suivante:

  ${TARGET}: pre-${TARGET} do-${TARGET} post-${TARGET}

(sauf si l'utilisateur a déjà fourni sa recette pour ${TARGET}.)

Les cibles pre-* et post-* sont réservées pour l'utilisateur.


Local Variables:
mode: text
tab-width: 4
End:
